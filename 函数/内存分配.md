-   详解下 new 函数
-   详解下 make 函数
-   详解下 new 和 make 之间的区别

# 🔥 1 详解下 new 函数

在 Go 语言中，`new` 函数是一个内置函数，用于分配并初始化一个类型的内存，并返回指向这块内存的指针。`new(T)` 函数会为类型 `T` 的新项分配零值初始化的存储空间，并返回其地址，即一个类型为 `*T` 的值。这里的零值指的是类型的默认值：例如，数值类型的零值是 `0`，布尔类型的零值是 `false`，指针类型的零值是 `nil`。

### 使用示例

假设你想创建一个 `int` 类型的变量并初始化为其零值，然后通过指针修改这个变量的值：

```go
package main

import "fmt"

func main() {
    a := new(int) // a 是一个指向 int 的指针，指向的 int 值被初始化为 0
    fmt.Println(*a) // 输出：0
    *a = 100        // 通过指针 a 修改值
    fmt.Println(*a) // 输出：100
}
```

在这个示例中，`new(int)` 创建了一个 `int` 类型的新变量，并将其初始化为 `0`（`int` 类型的零值）。`a` 是一个指向这个新分配的 `int` 的指针。随后，通过解引用 `a`（即 `*a`）来修改它指向的值。

### `new` 函数与复合字面量

`new` 函数相对比较简单且单一

功能。对于大多数类型，你同样可以使用复合字面量（composite literal）语法配合 `&` 操作符来创建并初始化新的变量，并获取其地址，这种方式更加灵活，因为它允许你在初始化时为变量的字段或元素指定值。

比较 `new` 函数和复合字面量的使用：

```go
// 使用 new 函数
a := new(int)
*b = 100

// 使用复合字面量
b := &int{100}
```

两种方式都会创建一个指向 `int` 类型变量的指针，且该变量的值为 `100`。但是复合字面量的方式更直观地表达了初始化变量的意图，并且允许一步到位地完成变量的创建、初始化和获取地址的过程。

### 使用场景

-   当你只需要分配一个零值变量，并且不需要立即进行初始化时，`new` 函数是一个方便的选择。
-   当你需要在初始化时指定更多的值或配置时，复合字面量会是更好的选择。

### `new` 用于自定义类型

`new` 同样适用于自定义类型：

```go
type MyStruct struct {
    Field1 int
    Field2 string
}

func main() {
    s := new(MyStruct)
    s.Field1 = 10
    s.Field2 = "Hello"
    fmt.Println(s) // 输出：&{10 Hello}
}
```

这里，`new(MyStruct)` 创建了一个 `MyStruct` 类型的新实例，并将其初始化为零值（即 `Field1` 为 `0`，`Field2` 为空字符串），然后我们通过指针来访问并设置结构体的字段。

### 总结

`new` 函数提供了一种简单的方式来分配并初始化变量的存储空间，尤其是当你只需要零值变量时。对于更复杂的初始化，或者当你需要直接在创建时指定初始值，使用复合字面量可能更为方便。在实际编程中，根据具体情况选择最适合的方法。

---

# 🔥 2 详解下 make 函数

在 Go 语言中，`make` 函数是一个内置函数，用于初始化内置的数据结构：切片（slice）、映射（map）和通道（channel）。与 `new` 函数不同，`make` 返回的是初始化后的（非零值的）类型实例，而不仅仅是指向零值的指针。

### `make` 函数的基本用法

-   **切片**：`make([]Type, length, capacity)` 创建一个 `Type` 类型的切片，长度设置为 `length`，容量设置为 `capacity`。如果省略容量，则容量等于长度。
-   **映射**：`make(map[KeyType]ValueType)` 创建一个 `KeyType` 到 `ValueType` 的映射。
-   **通道**：`make(chan Type, capacity)` 创建一个 `Type` 类型的通道，可选地指定缓冲区大小 `capacity`。

### 使用示例

#### 创建切片

```go
s := make([]int, 0, 5) // 创建一个整型切片，长度为 0，容量为 5
fmt.Println(s) // 输出：[]

// 可以直接追加元素
s = append(s, 1, 2, 3)
fmt.Println(s) // 输出：[1 2 3]
```

#### 创建映射

```go
m := make(map[string]int) // 创建一个从字符串到整数的映射
m["key"] = 42
fmt.Println(m) // 输出：map[key:42]
```

#### 创建通道

```go
ch := make(chan int, 2) // 创建一个整型通道，带有大小为 2 的缓冲区
ch <- 1
ch <- 2
fmt.Println(<-ch) // 输出：1
fmt.Println(<-ch) // 输出：2
```

### `make` 与 `new` 的区别

-   **`new(T)`** 返回的是一个指向类型 `T` 的零值的指针，即 `*T`。适用于所有类型，包括切片、映射、通道，但使用它们时通常需要额外的初始化步骤。
-   **`make(T, args...)`** 仅适用于切片、映射和通道，且返回的是一个初始化后的 `T` 类型的实例，而不是指针。使用 `make` 创建的数据结构是立即可用的，无需进一步初始化。

### 总结

`make` 函数在 Go 语言中用于创建并初始化切片、映射和通道三种复合数据类型的实例。与 `new` 不同，`make` 直接返回数据结构的实例，这些实例随即可用，无需进一步初始化。选择 `make` 还是 `new` 取决于你的具体需求，以及你想要创建的是哪种类型的数据结构。

---

# 🔥 3 详解下 new 和 make 之间的区别

在 Go 语言中，`new` 和 `make` 都是用于分配内存和初始化类型的内置函数，但它们在使用上有明显的区别。理解这两个函数之间的区别对于正确使用 Go 语言非常重要。

### `new` 函数

-   **用途**：`new(T)` 用于为给定类型 `T` 分配零值内存空间，并返回指向这块内存的指针，即 `*T`。这里的零值是指类型的默认值，比如数值类型为 `0`，布尔类型为 `false`，指针为 `nil` 等。
-   **返回值**：`new` 返回的是指向分配类型零值的指针。
-   **适用类型**：`new` 函数可以用于任何类型，包括基本类型（如 `int`、`float64`、`bool`）、复合类型（如 `struct`、`array`）、引用类型（如 `slice`、`map`、`chan`）等。
-   **使用示例**：
    ```go
    p := new(int)
    fmt.Println(*p) // 输出：0
    ```

### `make` 函数

-   **用途**：`make` 用于初始化内置的引用类型（即切片、映射和通道），并返回一个有初始值（非零值）的类型实例，而不是指针。
-   **返回值**：`make` 返回的是初始化后的类型实例本身，而不是指针。
-   **适用类型**：`make` 仅适用于切片（`slice`）、映射（`map`）和通道（`chan`）这三种引用类型。
-   **使用示例**：
    ```go
    s := make([]int, 0, 10)
    fmt.Println(s) // 输出：[]
    ```

### 主要区别

-   **返回类型**：`new` 返回指针，指向分配的零值内存空间；`make` 返回初始化的具体类型实例。
-   **适用类型**：`new` 可以应用于所有类型；`make` 仅用于切片、映射和通道。
-   **目的和结果**：`new` 主要用于类型的零值初始化，返回的是指向这个零值的指针；`make` 用于引用类型的内存分配和初始化，它返回的是一个初始化好的实例（对于切片是具有指定长度和容量的切片，对于映射是一个初始化好的映射，对于通道是一个具有指定缓冲能力的通道）。

### 总结

-   使用 `new` 当你需要分配一个零值变量，并且需要操作这个变量的指针。
-   使用 `make` 当你需要初始化切片、映射或通道，并且需要这些类型的一个非零值实例。
