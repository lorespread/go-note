# 1 接下下面的输出以及为什么

```go
package main

import "fmt"

func foo() (i int) {

    i = 0
    defer func() {
        fmt.Println(i)
    }()

    return 2
}

func main() {
    foo()
}
```

## 1 详情分析

这段代码在执行时会输出：

```
2
```

解释如下：

1. **函数返回值命名**：在 `foo` 函数的定义中，返回值被命名为 `i`。这意味着函数内部的任何对 `i` 的修改都直接影响到函数的返回值。

2. **初始化返回值**：函数内部首先将 `i` 设置为 `0`。

3. **`defer` 语句**：接着，`foo` 函数中注册了一个 `defer` 语句，该语句是一个匿名函数。由于它是通过闭包引用 `i` 的，所以它将在 `foo` 函数返回前访问 `i` 的最终值。

4. **返回值修改**：`foo` 函数最后执行 `return 2`。这个操作实际上做了两件事：

    - 首先，它将 `2` 赋值给 `i`。因为 `i` 是函数的返回值，所以这也确定了函数返回时 `i` 的值。
    - 然后，函数准备返回，但在这之前，它需要执行所有注册的 `defer` 语句。

5. **执行 `defer` 语句**：在 `foo` 函数真正返回之前，`defer` 中的匿名函数被调用。此时，它打印出 `i` 的值，也就是 `2`，因为在执行 `return 2` 时，`i` 被赋予了新的值。

6. **函数返回**：`foo` 函数返回值 `2`，但由于没有其他操作接收这个返回值（`main` 函数中调用 `foo()` 但没有使用其返回值），程序继续执行完毕。

### 总结

这个例子展示了 Go 语言中 `defer` 语句执行时机和返回值处理的特点。`defer` 语句会在函数返回前执行，此时函数的返回值已经确定，但还没有真正离开函数。因此，通过 `defer` 语句可以观察或修改函数的返回值。在这个特定例子中，`defer` 语句观察到的是函数返回值 `i` 在最后被修改为 `2` 的状态。
