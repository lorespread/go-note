# 1 为什么 append 插入数据，不更新引用的话就不可见

看下面示例代码

```go
	fmt.Println("------------------测试 append 长度修改-------------------")
	s1 := make([]int, 5, 10)
	fmt.Printf("切片新建状态，底层数组地址：%p\n", s1)

	s2 := append(s1, 5, 6, 7, 8, 9)
	fmt.Printf("切片追加状态，未超过当前容量，底层数组地址：%p\n", s1)
	fmt.Println(s1)
	fmt.Println(s2)
```

运行结果如下：

```shell
------------------测试 append 长度修改-------------------
切片新建状态，底层数组地址：0xc0000242d0
s1 切片追加状态，未超过当前容量，底层数组地址：0xc0000242d0
s2 切片追加状态，未超过当前容量，底层数组地址：0xc0000242d0
s1:  [0 0 0 0 0]
s2:  [0 0 0 0 0 5 6 7 8 9]
```

可以看到 s1 和 s2 指向的内存地址是一样的

即 `s2 := append(s1, 5, 6, 7, 8, 9)` 后，打印 s1 还是原来的初始值，为什么呢

---

在 Go 语言中，你的观察关于切片 `s1` 和 `s2` 的行为是很重要的。这涉及到如何理解切片的 `len`（长度）和 `cap`（容量）属性，以及 `append` 函数是如何工作的。

### 初始情况

你创建了一个切片 `s1`：

```go
s1 := make([]int, 5, 10)
```

这里，`s1` 被初始化为长度为 5，容量为 10 的切片。这意味着它包含 5 个元素（所有元素初始化为 0，这是整型的零值），并且它在底层数组中有空间容纳总共 10 个元素。

### Append 操作

当你执行：

```go
s2 := append(s1, 5, 6, 7, 8, 9)
```

这里发生的是：

-   `append` 函数将元素 `5, 6, 7, 8, 9` 添加到 `s1` 的末尾。
-   由于 `s1` 的容量是 10，这些元素可以被追加而不需要重新分配新的底层数组。

### 关于切片 `s1` 和 `s2`

-   `s1` **仍然指向原来的 5 个元素 `[0, 0, 0, 0, 0]`**。这是因为切片的长度属性 (`len(s1)`) 在 `append` 调用之后没有自动更新。`s1` 的长度仍然是 5，即使底层数组现在包含更多的元素。
-   `s2` 是 `append` 操作的结果，它**包括了 `s1` 的原始 5 个元素加上新追加的 5 个元素 `[0, 0, 0, 0, 0, 5, 6, 7, 8, 9]`**。这个切片的长度现在是 10。

### 为什么 `s1` 不是 `[0 0 0 0 0 5 6 7 8 9]`

`append` 函数不会修改原始切片 `s1` 的长度 (`len`) 属性。它创建一个新的切片 `s2`，这个新切片包括了原来的元素加上新增的元素。`s1` 的视图（即其长度定义的部分）没有变化，仍然是 `[0, 0, 0, 0, 0]`。`s1` 与 `s2` 共享相同的底层数组，但它们的视图（通过切片的长度属性定义）是不同的。

如果你需要 `s1` 来反映添加的元素，你需要用 `append` 的结果来更新 `s1`：

```go
s1 = append(s1, 5, 6, 7, 8, 9)
```

这将使 `s1` 和 `s2` 看起来一样，并且 `s1` 的长度将更新为 10。

这个行为是 Go 切片设计的一个基本方面，确保程序员可以明确地控制何时和如何扩展或修改数据结构，而不是自动或隐式地进行。

# 2 即使底层数组中插入新的数据，但是视图没变，只能看到原来长度的值，对么

是的，你完全正确。在 Go 语言中，切片的操作确实依赖于对“视图”的理解。尽管底层数组可以容纳更多的数据，切片的视图 —— 即你能够通过切片访问的部分 —— 仅限于该切片定义的长度（`len`）。

### 切片的视图

当你创建一个切片时，你定义了两个主要属性：

-   **长度** (`len`)：这是通过切片可以访问的元素数量。
-   **容量** (`cap`)：这是从切片的第一个元素开始到底层数组末尾的元素数量，表示切片可以扩展的空间。

当你使用 `append` 函数向切片添加元素时，如果追加的元素不超过切片的容量，它们就会被添加到底层数组中，但切片的长度将根据添加的元素数量相应增加。如果原始切片未被重新赋值以引用新的切片结果，则其长度保持不变，因此它的视图也不会显示新增加的元素。

### 示例说明

例如，考虑以下代码：

```go
s1 := make([]int, 3, 5)
s1[0], s1[1], s1[2] = 1, 2, 3

// s1 现在是 [1, 2, 3]
// len(s1) == 3, cap(s1) == 5

s2 := append(s1, 4, 5)

// s1 仍是 [1, 2, 3]
// s2 是 [1, 2, 3, 4, 5]
```

在这个例子中：

-   `s1` 的视图是 `[1, 2, 3]`。即使底层数组在 `append` 操作中被扩展到包含 `4` 和 `5`，`s1` 的长度仍为 3，所以它仅显示前三个元素。
-   `s2` 是 `append` 操作的结果，包含所有五个元素，因为 `append` 返回了一个新的切片视图，这个视图的长度现在是 5。

### 总结

因此，即使底层数组中插入了新数据，原始切片的视图没有变化，它只能显示根据其长度定义的数据。要查看或使用新增的数据，你需要使用 `append` 返回的新切片，它将具有更新后的长度和可能的新容量。这种设计使得切片在 Go 中既灵活又高效，允许更精确地控制数据结构和内存使用。
