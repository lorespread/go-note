```go
package main

import "fmt"

func main() {

	fmt.Println("------------------测试 append 追加，底层数组地址-------------------")
	s := make([]int, 5, 10)
	fmt.Printf("切片新建状态，底层数组地址：%p\n", s)

	_ = append(s, 5, 6, 7, 8)
	// fmt.Printf("切片追加状态，未超过当前容量，底层数组地址：%p\n", _)

	s = append(s, 10, 11)
	fmt.Printf("切片追加状态，超过当前容量，底层数组地址：%p\n", s)
	fmt.Println(s)
}
```

为什么执行的结果如下：

```shell
切片新建状态，底层数组地址：0xc000024320
切片追加状态，超过当前容量，底层数组地址：0xc000024320
[0 0 0 0 0 10 11]
```

打印的 s 变量不是 [0 0 0 0 0 5 6 7 8 10 11]

在你的代码中，有一个关键的地方需要注意，这关乎如何理解 `append` 函数返回值的使用。这里的关键是理解 `append` 函数的行为，特别是如何处理返回的新切片。让我们逐步分析：

### 初始切片状态

你创建了一个切片 `s`，初始长度为 5，容量为 10，所有元素都被初始化为 0。

```go
s := make([]int, 5, 10)
```

此时切片 `s` 的内容是 `[0, 0, 0, 0, 0]`。

### 使用 `append` 函数

接下来，你在代码中使用了 `append`：

```go
_ = append(s, 5, 6, 7, 8)
```

这一行代码向 `s` 追加了四个元素（5, 6, 7, 8）。重要的是，这个 `append` 调用的结果并没有赋值给任何变量（因为使用了 `_`），因此对 `s` 的原始视图没有任何影响。这意味着尽管底层数组被修改了，`s` 的长度还是 5，且这些更改在 `s` 的视图中是不可见的。

### 再次使用 `append`

然后，你有这样一个调用：

```go
s = append(s, 10, 11)
```

这一次，你将结果赋给了 `s`。此时，`append` 需要处理已经从前一个 `append` 调用中存在的数据（即使这些数据没有被赋值回 `s`，底层数组已经包括这些值）。因为原始切片 `s` 的容量足够大（10），这次追加不会导致新的内存分配，除非前面的元素已经填充到底层数组的末端。

由于前一个 `append` 的结果没有保存，所以当你执行第二次 `append` 并赋值给 `s` 时，`s` 只会包含原来的五个零和新增的两个元素（10, 11），而不是所有追加的元素。

### 最终的打印

最终，打印 `s` 时：

```go
fmt.Println(s)
```

显示的是 `[0 0 0 0 0 10 11]`。这是因为只有最后的 `append` 操作的结果被保存并反映在 `s` 上。

### 总结

要使所有追加的元素都反映在 `s` 上，你需要连续地更新 `s` 来保存每次 `append` 操作的结果，如下所示：

```go
s = append(s, 5, 6, 7, 8)
s = append(s, 10, 11)
```

这样，`s` 最终会包含 `[0 0 0 0 0 5 6 7 8 10 11]`，因为每次 `append` 调用的结果都被正确地处理和保存。
