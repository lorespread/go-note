# 分析下这段代码为什么会运行失败

```go
func main() {
    var a *int
    *a = 100
    fmt.Println(*a)

    var b map[string]int
    b["测试"] = 100
    fmt.Println(b)
}
```

执行上面的代码会引发 panic，为什么呢？在 Go 语言中对于引用类型的变量，我们在使用的时候不仅要声明它，还要为它分配内存空间，否则我们的值就没办法存储。而对于值类型的声明不需要分配内存空间，是因为它们在声明的时候已经默认分配好了内存空间。要分配内存，就引出来今天的 new 和 make。Go 语言中 new 和 make 是内建的两个函数，主要用来分配内存

# 1 引用类型都包含了哪些数据类型

在 Go 语言中，引用类型（reference types）是那些使用引用来访问底层数据结构的类型。引用类型的变量存储的是一个指向数据的指针，而不是数据本身。这意味着当这些变量被赋值给另一个变量或作为参数传递给函数时，操作的是数据的引用，因此任何修改都会影响到原始数据。

Go 语言中的引用类型主要包括：

1. **切片（Slices）**：动态数组，可以快速访问数据集合的一部分或全部，并且其大小可以根据需要自动扩展。
2. **映射（Maps）**：存储键值对的集合，其中的键是唯一的，通过键可以快速查找对应的值。

3. **通道（Channels）**：用于在不同的执行线程（goroutines）之间传递数据的管道。

4. **指针（Pointers）**：包含了另一个变量的内存地址。通过指针，可以直接读取或修改该地址处的数据。

5. **函数（Functions）**：在 Go 中，函数也是一种类型，可以像其他类型一样被赋值和传递。

除了上述提到的引用类型，还有一些特殊的类型，如接口（Interfaces），它们在某些方面表现得像引用类型，尽管接口的工作原理有所不同，主要用于定义一组方法签名，由其他类型实现。

### 引用类型的特点

-   **内存管理**：引用类型的变量在赋值和传递时只会复制指针，而不会复制实际的数据。因此，对变量的修改会反映在所有引用了相同数据的变量中。

-   **零值**：引用类型的零值是 `nil`，表示没有分配任何内存。在使用前，这些类型的变量通常需要通过 `make` 函数（对于切片、映射和通道）或通过赋值（对于指针和函数）进行初始化。

### 示例

**切片**：

```go
s := make([]int, 0, 10) // 创建一个整型切片，长度为 0，容量为 10
```

**映射**：

```go
m := make(map[string]int) // 创建一个从字符串到整型的映射
```

**通道**：

```go
ch := make(chan int) // 创建一个无缓冲的整型通道
```

**指针**：

```go
var p *int
x := 10
p = &x // p 指向 x
```

**函数**：

```go
var f func(string) int
f = func(s string) int { return len(s) }
```

通过理解和正确使用引用类型，可以编写出更高效、更灵活的 Go 程序。

# 2 结构体是不是引用类型

不，结构体（struct）在 Go 语言中是值类型，而不是引用类型。

### 值类型 vs 引用类型

-   **值类型（Value Types）**：变量直接存储数据值，而且每个变量都拥有自己的数据副本。在赋值或传递给函数（作为参数）时，实际上操作的是数据的拷贝。基本数据类型（如 `int`、`float64`、`bool`、`string` 等）和结构体（`struct`）都是值类型。
-   **引用类型（Reference Types）**：变量存储的是数据的引用，即数据在内存中的地址。当引用类型的变量被赋值给另一个变量时，两个变量都指向相同的数据对象，因此对其中一个变量的修改会影响到另一个变量。引用类型包括切片（`slice`）、映射（`map`）、通道（`chan`）、指针（`pointer`）、函数（`function`）等。

### 结构体的行为

当一个结构体赋值给另一个变量时，被赋值的变量会获得原始结构体数据的一个完整拷贝。这意味着如果你修改新变量中的一个字段，原始结构体中对应的字段不会受到影响：

```go
type Person struct {
    Name string
    Age  int
}

func main() {
    p1 := Person{"John", 30}
    p2 := p1          // p2 是 p1 的一个副本
    p2.Name = "Jane"  // 修改 p2 的 Name 不会影响 p1

    fmt.Println(p1) // 输出：{John 30}
    fmt.Println(p2) // 输出：{Jane 30}
}
```

### 使用结构体指针实现引用行为

虽然结构体本身是值类型，但你可以通过使用结构体的指针来实现引用行为。当你将结构体的指针传递给函数或赋值给另一个变量时，操作的是结构体数据的同一个实例：

```go
func main() {
    p1 := &Person{"John", 30}
    p2 := p1          // p2 和 p1 指向同一个 Person 实例
    p2.Name = "Jane"  // 修改 p2 也会影响 p1

    fmt.Println(*p1) // 输出：{Jane 30}
    fmt.Println(*p2) // 输出：{Jane 30}
}
```

### 总结

结构体在 Go 语言中是值类型，它们在赋值和传递时会被拷贝。如果需要引用同一个结构体实例，可以使用结构体指针。通过理解值类型和引用类型的差异，你可以更好地控制数据在程序中的传递和修改行为。
