# 1 分析下下面这段错误的代码

```go
func main() {
    var a *int
    *a = 100
    fmt.Println(*a)

    var b map[string]int
    b["测试"] = 100
    fmt.Println(b)
}

```

这段代码存在两个主要问题，都与尝试对未初始化的数据结构进行操作有关：

### 对未初始化的指针解引用

```go
var a *int
*a = 100
```

在这里，`a` 是一个指向 `int` 类型的指针，它的零值是 `nil`，也就是说它没有指向任何有效的内存地址。尝试通过 `*a = 100` 对它进行解引用赋值时，你实际上是尝试向一个 `nil` 指针指向的位置写入值，这会导致运行时错误（panic），因为你试图访问一个无效的内存地址。

为了正确地赋值，你需要先为 `a` 分配内存。这通常通过使用 `new` 函数或取已存在变量的地址来完成：

```go
a := new(int) // 使用 new 为 int 类型分配内存，a 指向这个内存
*a = 100 // 现在可以安全地赋值
```

或者：

```go
var value int
a := &value // a 现在指向 value
*a = 100 // 可以通过 a 来修改 value 的值
```

### 对未初始化的映射（map）赋值

```go
var b map[string]int
b["测试"] = 100
```

这里，`b` 是一个映射（map）从 `string` 到 `int`。它的零值也是 `nil`，意味着它没有指向任何实际的映射结构。直接尝试向 `b` 赋值同样会导致运行时错误，因为你尝试操作一个尚未初始化的映射。

映射需要使用 `make` 函数初始化后才能使用：

```go
b := make(map[string]int)
b["测试"] = 100 // 现在可以安全地赋值
```

### 总结

你的代码示例中的问题都源于尝试对未经初始化的指针和映射进行操作。在 Go 中，对于指针、切片、映射等引用类型，进行操作之前必须先进行适当的初始化，否则会引发运行时错误。通过使用 `new`、`&` 或 `make` 函数，可以安全地初始化这些类型，从而避免错误。
